package S9_BitNumberMath;

public class BasicOperations {
    public static void main(String[] args) {
        int a = 10; // 00001010
        int b = 38; // 00100110

        // & 与运算
        // 1 & 1 = 1
        // 0 & 1 = 0
        // 1 & 0 = 0
        // 0 & 0 = 0
        // a & b = 00000010 = 2
        System.out.println(a & b);

        // | 或运算
        // 1 | 1 = 1
        // 1 | 0 = 1
        // 0 | 1 = 1
        // 0 | 0 = 0
        // A | B = 00101110 = 32 + 8 + 4 + 2 = 46
        System.out.println(a | b);

        // ^ 亦或运算 --> 不进位加法
        // 1 ^ 1 = 0
        // 1 ^ 0 = 1
        // 0 ^ 1 = 1
        // 0 ^ 0 = 0
        // a ^ b = 00101100 = 4 + 8 + 32 = 44
        System.out.println(a ^ b);

        // ~ 非操作 --> 取反操作
        // ~a
        System.out.println(~10);  // -11
        System.out.println(~-10); // 9

        // << 左移操作 --> 向左移动一位 = X 2， 左移两位 = X 2 X 2
        // 00001010 << 1 --> 00010100
        // a << 1 = 00010100 = 16 + 4 = 20
        // a << 2 = 00101000 = 8 + 32 = 40
        System.out.println(a << 4); // 10 * 16 = 160 左移操作比乘法运算要快很多

        // >> 右移操作 --> / 2
        // a >> 1 --> 00000101 = 1 + 4 = 5
        // a >> 2 --> 00000010 = 2
        System.out.println(b >> 3); //00000100 = 4

        // >>> 逻辑右移 主要不同在涉及负数的时候,在面对正数时由于都是最高位补0，所以逻辑右移与普通右移结果是一致的
        // 11100011111000111110001111100011 >> 1 --> 11110001111100011111000111110001 //普通右移的话，负数还是负数，头部补1
        // 11100011111000111110001111100011 >>> 1 --> 01110001111100011111000111110001 //逻辑右移最高位无脑补0，负数变正数
        System.out.println(-10 >> 2);  // - 3
        System.out.println(-10 >>> 2); // 1073741821
        // 数值是以补码(complement)表示的
        // 求负数的补码方法是：将该数的绝对值的二进制形式，按位取反再加1
        // 负数普通右移为补码运算
        //-10:原码：1000 1010，反码：1111 0101，补码：1111 0110
        //补码右移2位变成：1111 1101，变成原码：1000 0011 -> -3
        //10:0000 1010右移2位：0000 0010 ->2
    }
}
